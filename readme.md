# Домашнее задание № 1
## Работа с github

**Для успешного выполнения домашних заданий вам потребуется:**

1. **Создать персональную копию репозитория**  
   Выполните *fork* данного репозитория на своём аккаунте GitHub — это создаст независимую копию для вашей работы.

2. **Настроить правила:**
   1. Перейдите в `Settings` → `Branches` вашего форка
   2. Добавьте правила для ветки `main`: `Add classic branch protection rule`
   3. Установите `Branch name pattern` = main
   3. Включите опции:
      - Require a pull request before merging
      - Require approvals 
      - Require status checks to pass
      - Do not allow bypassing the above settings

3. **Добавьте ревьюера:**
   1. Перейдите в `Settings` → `Collaborators` вашего форка
   2. В поле `Add people` введите логин GitHub вашего коллеги и нажмите Add.
   3. Теперь этот человек будет иметь доступ к вашему форку и вы сможете назначать его ревьюером в PR, созданных внутри вашего форка.

3. **Настроить безопасное подключение**  
   Настройте *SSH-ключ* или получите *токен аутентификации* для безопасного доступа к репозиторию без ввода пароля.

4. **Склонировать репозиторий локально**  
   Используйте команду `git clone` для загрузки репозитория на ваш компьютер.

5. **Создать рабочую ветку**  
   На основе ветки `main` создайте новую ветку с произвольным названием для разработки решения.

6. **Реализовать решения задач**  
   В созданной ветке напишите код для трёх задач, разместив решения и тестовые примеры в соответствии со структурой проекта, описанной ниже.

7. **Завершить и проверить решение**  
   После завершения разработки убедитесь, что:
   - Все тесты проходят успешно
   - CI/CD pipeline показывает положительный результат
   - Код соответствует требованиям

8. **Создать запрос на слияние**  
   Отправьте *Pull Request* для объединения вашей ветки с исходным репозиторием.

**Важно:** Сохраняйте соответствие структуре проекта и обеспечивайте прохождение всех автоматических проверок перед отправкой работы.

Гайд по созданию персональной копии репозитория и аутентификации есть [здесь](./guide_git/readme.md)

## Структура проекта
```
.
├── cmd
│   └── main.go // функция main() с вышими примерами вызовов реализованных функций (надо создать самостоятельно)
├── go.mod
├── go.sum
├── internal
│   ├── task_1
│   │   ├── errors.go               // описание возможных ошибок для функции filterCommonDigits
│   │   └── filterCommonDigits.go   // реализация функции для задания 1  (надо создать самостоятельно)
│   ├── task_2
│   │   ├── errors.go
│   │   ├── files
│   │   │   └── ... // файлы необходимые для самостоятельного тестирования из main  (надо создать самостоятельно)
│   │   └── findCommonWords.go  //  (надо создать самостоятельно)
│   └── task_3
│       ├── errors.go
│       └── scaleSlice.go   //  (надо создать самостоятельно)
└─ readme.md
```

## Общие требования
Для каждой функции в `main()` необходимо предоставить примеры вызовов с различными входными данными, включая граничные условия. Каждый тест должен содержать ожидаемый вывод функции.

### Пример оформления тестов (для функции divide)
```go
// Пример вызова 1: обычное деление
quotient, remainder, err := divide(10, 3)
fmt.Printf("divide(10, 3) = (%d, %d, %v), expected: (3, 1, nil)\n", quotient, remainder, err)

// Пример вызова 2: деление нацело
quotient, remainder, err = divide(20, 5)
fmt.Printf("divide(20, 5) = (%d, %d, %v), expected: (4, 0, nil)\n", quotient, remainder, err)

// Пример вызова 3: деление нуля
quotient, remainder, err = divide(0, 5)
fmt.Printf("divide(0, 5) = (%d, %d, %v), expected: (0, 0, nil)\n", quotient, remainder, err)

// Пример вызова 4: деление на ноль (граничное условие)
quotient, remainder, err = divide(10, 0)
fmt.Printf("divide(10, 0) = (%d, %d, %v), expected: (0, 0, error)\n", quotient, remainder, err)

// Пример вызова 5: большие числа
quotient, remainder, err = divide(1000000, 999)
fmt.Printf("divide(1000000, 999) = (%d, %d, %v), expected: (1001, 1, nil)\n", quotient, remainder, err)

// Пример вызова 6: оба аргумента отрицательные
quotient, remainder, err = divide(-15, -4)
fmt.Printf("divide(-15, -4) = (%d, %d, %v), expected: (3, -3, nil)\n", quotient, remainder, err)
```

## Задача 1: Фильтр общих цифр

### Описание
Функция `FilterCommonDigits` принимает два целых положительных числа и возвращает эти же числа, из которых удалены все цифры, присутствующие в обоих исходных числах, и ошибку (или nil при успешном выполнении).


### Сигнатура функции
```go
func FilterCommonDigits(a, b int) (int, int, error)
```


### Требования
1. Если входные числа отрицательные - возвращать ошибку `ErrNegNums`;
2. Если в результате фильтрации одно из чисел становится пустым - возвращать ошибку `ErrEmptyNum`;
3. Сохранять порядок цифр в исходных числах.


## Задача 2: Поиск общих слов в файлах

### Описание
Напишите функцию `FindCommonWords`, которая принимает имя результирующего файла для записи результата и переменное количество строк с названиями входных. 

Функция находит слова, которые присутствуют во всех переданных текстовых файлах `inputFilenames`, и записывает их в результирующий файл `outputFilename`.

### Сигнатура функции
```go
func FindCommonWords(outputFilename string, inputFilenames ...string) error
```

### Требования
1. Если какой-либо файл не существует или не открывается - возвращать ошибку `ErrOpenFile`;
2. Слова разделяются пробелами и переносами строк;
3. Регистр слов должен учитываться;
4. Возвращать ошибку или nil.

## Задача 3: Масштабирование среза

### Описание
Функция `ScaleSlice` принимает срез целых чисел и коэффициент масштабирования (целое неотрицательное число), увеличивает размер исходного среза в указанное количество раз, заполняя новые элементы копиями исходных данных. 

Функция должна вернуть ошибку `ErrOverflow`, если результат умножения (длина исходного среза × коэффициент масштабирования) превышает максимальное значение типа uint32.

### Сигнатура функции
```go
func ScaleSlice(slice *[]int, scaleFactor uint32) error
```

## Критерии приема
1. Все функции реализованы согласно требованиям
2. Предоставлены тестовые примеры 
3. Результаты тестовых примеров полностью соответствуют ожидаемому поведению
4. Обработка ошибок реализована корректно
5. Код читаем 
